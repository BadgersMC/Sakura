From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "kfian294ma4@gmail.com" <kfian294ma4@gmail.com>
Date: Sun, 5 Sep 2021 18:01:34 +0100
Subject: [PATCH] Sakura Configuration Files


diff --git a/src/main/java/io/papermc/paper/configuration/Configurations.java b/src/main/java/io/papermc/paper/configuration/Configurations.java
index 9ef6712c70fcd8912a79f3f61e351aac09572cf3..4cb0c8291833cd10d9704cdbe4f0332827c02ae2 100644
--- a/src/main/java/io/papermc/paper/configuration/Configurations.java
+++ b/src/main/java/io/papermc/paper/configuration/Configurations.java
@@ -88,7 +88,7 @@ public abstract class Configurations<G, W> {
         };
     }
 
-    static <T> CheckedFunction<ConfigurationNode, T, SerializationException> reloader(Class<T> type, T instance) {
+    public static <T> CheckedFunction<ConfigurationNode, T, SerializationException> reloader(Class<T> type, T instance) { // Sakura - public
         return node -> {
             ObjectMapper.Factory factory = (ObjectMapper.Factory) Objects.requireNonNull(node.options().serializers().get(type));
             ObjectMapper.Mutable<T> mutable = (ObjectMapper.Mutable<T>) factory.get(type);
@@ -206,7 +206,7 @@ public abstract class Configurations<G, W> {
             .path(worldConfigFile)
             .build();
         final ConfigurationNode worldNode = worldLoader.load();
-        if (newFile) { // set the version field if new file
+        if (newFile && this instanceof PaperConfigurations) { // Sakura - hack this into working // set the version field if new file
             worldNode.node(Configuration.VERSION_FIELD).set(WorldConfiguration.CURRENT_VERSION);
         }
         this.applyWorldConfigTransformations(contextMap, worldNode);
diff --git a/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java b/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
index 9e8b8de907654050c51400286af971caca87d6bd..8e173ad0adc71c295394e61bbabf11336bd10332 100644
--- a/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
+++ b/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
@@ -449,7 +449,7 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
     }
 
     // Symlinks are not correctly checked in createDirectories
-    static void createDirectoriesSymlinkAware(Path path) throws IOException {
+    public static void createDirectoriesSymlinkAware(Path path) throws IOException { // Sakura - make public
         if (!Files.isDirectory(path)) {
             Files.createDirectories(path);
         }
diff --git a/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceFactory.java b/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceFactory.java
index cec678ae24a7d99a46fa672be907f4c28fe4da96..9906ef363c72ade71c16d8141a0d6d79d72d4eff 100644
--- a/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceFactory.java
+++ b/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceFactory.java
@@ -11,13 +11,13 @@ import org.spongepowered.configurate.serialize.SerializationException;
 
 import static io.leangen.geantyref.GenericTypeReflector.erase;
 
-final class InnerClassInstanceFactory implements FieldDiscoverer.MutableInstanceFactory<Map<Field, Object>> {
+public final class InnerClassInstanceFactory implements FieldDiscoverer.MutableInstanceFactory<Map<Field, Object>> { // Sakura
 
     private final InnerClassInstanceSupplier instanceSupplier;
     private final FieldDiscoverer.MutableInstanceFactory<Map<Field, Object>> fallback;
     private final AnnotatedType targetType;
 
-    InnerClassInstanceFactory(final InnerClassInstanceSupplier instanceSupplier, final FieldDiscoverer.MutableInstanceFactory<Map<Field, Object>> fallback, final AnnotatedType targetType) {
+    public InnerClassInstanceFactory(final InnerClassInstanceSupplier instanceSupplier, final FieldDiscoverer.MutableInstanceFactory<Map<Field, Object>> fallback, final AnnotatedType targetType) { // Sakura
         this.instanceSupplier = instanceSupplier;
         this.fallback = fallback;
         this.targetType = targetType;
diff --git a/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceSupplier.java b/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceSupplier.java
index 8d8bc050441c02cf65dfcb6400978363d6b8ef10..5872095a811452037cc0772ba2a31bf9a795cc82 100644
--- a/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceSupplier.java
+++ b/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceSupplier.java
@@ -19,7 +19,7 @@ import static io.leangen.geantyref.GenericTypeReflector.erase;
  * {@link ConfigurationPart}. Only 1 instance of each {@link ConfigurationPart} should be present for each instance
  * of the field discoverer this is used in.
  */
-final class InnerClassInstanceSupplier implements CheckedFunction<AnnotatedType, @Nullable Supplier<Object>, SerializationException> {
+public final class InnerClassInstanceSupplier implements CheckedFunction<AnnotatedType, @Nullable Supplier<Object>, SerializationException> { // Sakua - :<
 
     private final Map<Class<?>, Object> instanceMap = new HashMap<>();
     private final Map<Class<?>, Object> initialOverrides;
@@ -27,7 +27,7 @@ final class InnerClassInstanceSupplier implements CheckedFunction<AnnotatedType,
     /**
      * @param initialOverrides map of types to objects to preload the config objects with.
      */
-    InnerClassInstanceSupplier(final Map<Class<?>, Object> initialOverrides) {
+    public InnerClassInstanceSupplier(final Map<Class<?>, Object> initialOverrides) { // Sakura
         this.initialOverrides = initialOverrides;
     }
 
diff --git a/src/main/java/me/samsuik/sakura/command/BaseSubCommand.java b/src/main/java/me/samsuik/sakura/command/BaseSubCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b5af05f7a4593eb44f36fff90d94e98d6999c7f
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/command/BaseSubCommand.java
@@ -0,0 +1,47 @@
+package me.samsuik.sakura.command;
+
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@DefaultQualifier(NonNull.class)
+public abstract class BaseSubCommand extends Command {
+
+    public BaseSubCommand(String name) {
+        super(name);
+        this.description = "Sakura Command " + name;
+        this.setPermission("bukkit.command." + name);
+    }
+
+    public abstract void execute(CommandSender sender, String[] args);
+
+    public void tabComplete(List<String> list, String[] args) throws IllegalArgumentException {}
+
+    @Override
+    @Deprecated
+    public final boolean execute(CommandSender sender, String label, String[] args) {
+        if (testPermission(sender)) {
+            execute(sender, args);
+        }
+
+        return true;
+    }
+
+    @Override
+    @NotNull
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        var completions = new ArrayList<String>(0);
+
+        if (testPermissionSilent(sender)) {
+            tabComplete(completions, args);
+        }
+
+        return completions;
+    }
+
+}
diff --git a/src/main/java/me/samsuik/sakura/command/SakuraCommand.java b/src/main/java/me/samsuik/sakura/command/SakuraCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..f4e75ba8f2c53a82cb40868f0e1ab77ffcc19e3e
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/command/SakuraCommand.java
@@ -0,0 +1,93 @@
+package me.samsuik.sakura.command;
+
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+@DefaultQualifier(NonNull.class)
+public class SakuraCommand extends Command {
+
+    private static final Component INFORMATION_MESSAGE = MiniMessage.miniMessage().deserialize("""
+        <dark_purple>.</dark_purple>
+        <dark_purple>| <white>This is the main command for <gradient:red:light_purple:0.5>Sakura</gradient>.
+        <dark_purple>| <white>All exclusive commands are listed below."""
+    );
+
+    private static final String COMMAND_MSG = "<dark_purple>| <dark_gray>*</dark_gray> /<light_purple><command>";
+
+    public SakuraCommand(String name) {
+        super(name);
+
+        this.description = "";
+        this.usageMessage = "/sakura";
+        this.setPermission("bukkit.command.sakura");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (args.length > 0) {
+            var commands = new ArrayList<>(SakuraCommands.COMMANDS.values());
+
+            // This part is copied from the VersionCommand SubCommand in paper
+            @Nullable
+            var internalVersion = MinecraftServer.getServer().server.getCommandMap().getCommand("version");
+            if (internalVersion != null) {
+                commands.add(internalVersion);
+            }
+
+            for (var base : commands) {
+                if (base.getName().equalsIgnoreCase(args[0])) {
+                    return base.execute(sender, commandLabel, Arrays.copyOfRange(args, 1, args.length));
+                }
+            }
+        }
+
+        sendHelpMessage(sender);
+        return false;
+    }
+
+    private void sendHelpMessage(CommandSender sender) {
+        sender.sendMessage(INFORMATION_MESSAGE);
+
+        var uniqueCommands = SakuraCommands.COMMANDS.values()
+            .stream()
+            .filter(command -> command != this);
+
+        uniqueCommands.forEach((command) -> {
+            sender.sendMessage(MiniMessage.miniMessage().deserialize(COMMAND_MSG,
+                Placeholder.unparsed("command", command.getName()))
+            );
+        });
+
+        sender.sendMessage(Component.text("'", NamedTextColor.DARK_PURPLE));
+    }
+
+    @NotNull
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        if (!testPermissionSilent(sender)) {
+            return Collections.emptyList();
+        }
+
+        return SakuraCommands.COMMANDS.values().stream()
+            .filter(command -> command != this) // ahem
+            .map(Command::getName)
+            .filter(name -> args.length <= 1 || name.startsWith(args[args.length - 1]))
+            .toList();
+    }
+
+}
diff --git a/src/main/java/me/samsuik/sakura/command/SakuraCommands.java b/src/main/java/me/samsuik/sakura/command/SakuraCommands.java
new file mode 100644
index 0000000000000000000000000000000000000000..c2651cac1dcf85fb67fe981b97efee4e56431de2
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/command/SakuraCommands.java
@@ -0,0 +1,26 @@
+package me.samsuik.sakura.command;
+
+import io.papermc.paper.command.PaperPluginsCommand;
+import me.samsuik.sakura.command.subcommands.ConfigCommand;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class SakuraCommands {
+
+    static final Map<String, Command> COMMANDS = new HashMap<>();
+    static {
+        COMMANDS.put("sakura", new SakuraCommand("sakura"));
+        COMMANDS.put("config", new ConfigCommand("config"));
+    }
+
+    public static void registerCommands(final MinecraftServer server) {
+        COMMANDS.forEach((s, command) -> {
+            server.server.getCommandMap().register(s, "sakura", command);
+        });
+        server.server.getCommandMap().register("bukkit", new PaperPluginsCommand());
+    }
+
+}
diff --git a/src/main/java/me/samsuik/sakura/command/subcommands/ConfigCommand.java b/src/main/java/me/samsuik/sakura/command/subcommands/ConfigCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b5f50c7447d1c1732a745bae54c4fcd4f45da46
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/command/subcommands/ConfigCommand.java
@@ -0,0 +1,45 @@
+package me.samsuik.sakura.command.subcommands;
+
+import me.samsuik.sakura.command.BaseSubCommand;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collections;
+import java.util.List;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.GREEN;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+@DefaultQualifier(NonNull.class)
+public class ConfigCommand extends BaseSubCommand {
+
+    public ConfigCommand(String name) {
+        super(name);
+        this.description = "Command for reloading the sakura configuration file";
+    }
+
+    @Override
+    public void execute(CommandSender sender, String[] args) {
+        Command.broadcastCommandMessage(sender, text("Please note that this command is not supported and may cause issues.", RED));
+        Command.broadcastCommandMessage(sender, text("If you encounter any issues please use the /stop command to restart your server.", RED));
+
+        MinecraftServer server = ((CraftServer) sender.getServer()).getServer();
+        server.sakuraConfigurations.reloadConfigs(server);
+        server.server.reloadCount++;
+
+        Command.broadcastCommandMessage(sender, text("Sakura config reload complete.", GREEN));
+    }
+
+    @NotNull
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        return Collections.emptyList();
+    }
+
+}
diff --git a/src/main/java/me/samsuik/sakura/configuration/GlobalConfiguration.java b/src/main/java/me/samsuik/sakura/configuration/GlobalConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..bc6db446dca3024b8f6d3f24499242775dd02219
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/configuration/GlobalConfiguration.java
@@ -0,0 +1,42 @@
+package me.samsuik.sakura.configuration;
+
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.configuration.Configuration;
+import io.papermc.paper.configuration.ConfigurationPart;
+import org.slf4j.Logger;
+import org.spongepowered.configurate.objectmapping.meta.Setting;
+
+@SuppressWarnings({"CanBeFinal", "FieldCanBeLocal", "FieldMayBeFinal", "NotNullFieldNotInitialized", "InnerClassMayBeStatic", "RedundantSuppression"})
+public class GlobalConfiguration extends ConfigurationPart {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+    static final int CURRENT_VERSION = 1;// (when you change the version, change the comment, so it conflicts on rebases): rename filter bad nbt from spawn eggs
+
+    private static GlobalConfiguration instance;
+    public static GlobalConfiguration get() {
+        return instance;
+    }
+
+    static void set(GlobalConfiguration instance) {
+        GlobalConfiguration.instance = instance;
+    }
+
+    @Setting(Configuration.VERSION_FIELD)
+    public int version = CURRENT_VERSION;
+
+    public Fps fps;
+    public class Fps extends ConfigurationPart {
+        public String message = "<dark_gray>(<light_purple>S</light_purple>) <gray><state> <yellow><name>";
+        public String material = "pink_stained_glass_pane";
+    }
+
+    public Cannons cannons;
+    public class Cannons extends ConfigurationPart {
+        public Explosion explosion = new Explosion();
+        
+        public class Explosion extends ConfigurationPart {
+            public boolean reducedSearchRays;
+        }
+    }
+
+}
diff --git a/src/main/java/me/samsuik/sakura/configuration/SakuraConfigurations.java b/src/main/java/me/samsuik/sakura/configuration/SakuraConfigurations.java
new file mode 100644
index 0000000000000000000000000000000000000000..37f41089a2fb7ad11ceda07cf5de0fc8b34b8db2
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/configuration/SakuraConfigurations.java
@@ -0,0 +1,220 @@
+package me.samsuik.sakura.configuration;
+
+import com.google.common.collect.Table;
+import com.mojang.logging.LogUtils;
+import io.leangen.geantyref.TypeToken;
+import io.papermc.paper.configuration.ConfigurationPart;
+import io.papermc.paper.configuration.Configurations;
+import io.papermc.paper.configuration.NestedSetting;
+import io.papermc.paper.configuration.PaperConfigurations;
+import io.papermc.paper.configuration.serializer.*;
+import io.papermc.paper.configuration.serializer.collections.FastutilMapSerializer;
+import io.papermc.paper.configuration.serializer.collections.MapSerializer;
+import io.papermc.paper.configuration.serializer.collections.TableSerializer;
+import io.papermc.paper.configuration.serializer.registry.RegistryHolderSerializer;
+import io.papermc.paper.configuration.serializer.registry.RegistryValueSerializer;
+import io.papermc.paper.configuration.type.BooleanOrDefault;
+import io.papermc.paper.configuration.type.Duration;
+import io.papermc.paper.configuration.type.DurationOrDisabled;
+import io.papermc.paper.configuration.type.EngineMode;
+import io.papermc.paper.configuration.type.number.DoubleOr;
+import io.papermc.paper.configuration.type.number.IntOr;
+import it.unimi.dsi.fastutil.objects.Reference2IntMap;
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Reference2LongMap;
+import it.unimi.dsi.fastutil.objects.Reference2LongOpenHashMap;
+import me.samsuik.sakura.configuration.mapping.InnerClassFieldDiscoverer;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
+import org.slf4j.Logger;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.ConfigurationOptions;
+import org.spongepowered.configurate.objectmapping.ObjectMapper;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.nio.file.Path;
+import java.util.function.Function;
+
+import static io.leangen.geantyref.GenericTypeReflector.erase;
+
+@SuppressWarnings("Convert2Diamond")
+public class SakuraConfigurations extends Configurations<GlobalConfiguration, WorldConfiguration> {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+    static final String GLOBAL_CONFIG_FILE_NAME = "sakura-global.yml";
+    static final String WORLD_DEFAULTS_CONFIG_FILE_NAME = "sakura-world-defaults.yml";
+    static final String WORLD_CONFIG_FILE_NAME = "sakura-world.yml";
+    public static final String CONFIG_DIR = "config";
+
+    private static final String GLOBAL_HEADER = String.format("""
+            This is the global configuration file for Sakura.
+            As you can see, there's a lot to configure. Some options may impact gameplay, so use
+            with caution, and make sure you know what each option does before configuring.
+
+            The world configuration options have been moved inside
+            their respective world folder. The files are named %s""", WORLD_CONFIG_FILE_NAME);
+
+    private static final String WORLD_DEFAULTS_HEADER = """
+            This is the world defaults configuration file for Sakura.
+            As you can see, there's a lot to configure. Some options may impact gameplay, so use
+            with caution, and make sure you know what each option does before configuring.
+
+            Configuration options here apply to all worlds, unless you specify overrides inside
+            the world-specific config file inside each world folder.""";
+
+    private static final Function<ContextMap, String> WORLD_HEADER = map -> String.format("""
+        This is a world configuration file for Sakura.
+        This file may start empty but can be filled with settings to override ones in the %s/%s
+        
+        World: %s (%s)""",
+        SakuraConfigurations.CONFIG_DIR,
+        SakuraConfigurations.WORLD_DEFAULTS_CONFIG_FILE_NAME,
+        map.require(WORLD_NAME),
+        map.require(WORLD_KEY)
+    );
+
+    public SakuraConfigurations(final Path globalFolder) {
+        super(globalFolder, GlobalConfiguration.class, WorldConfiguration.class, GLOBAL_CONFIG_FILE_NAME, WORLD_DEFAULTS_CONFIG_FILE_NAME, WORLD_CONFIG_FILE_NAME);
+    }
+
+    @Override
+    protected YamlConfigurationLoader.Builder createLoaderBuilder() {
+        return super.createLoaderBuilder()
+            .defaultOptions(SakuraConfigurations::defaultOptions);
+    }
+
+    private static ConfigurationOptions defaultOptions(ConfigurationOptions options) {
+        return options.serializers(builder -> builder
+            .register(MapSerializer.TYPE, new MapSerializer(false))
+            .register(new EnumValueSerializer())
+            .register(new ComponentSerializer())
+        );
+    }
+
+    @Override
+    protected ObjectMapper.Factory.Builder createGlobalObjectMapperFactoryBuilder() {
+        return defaultGlobalFactoryBuilder(super.createGlobalObjectMapperFactoryBuilder());
+    }
+
+    private static ObjectMapper.Factory.Builder defaultGlobalFactoryBuilder(ObjectMapper.Factory.Builder builder) {
+        return builder.addDiscoverer(InnerClassFieldDiscoverer.globalConfig());
+    }
+
+    @Override
+    protected YamlConfigurationLoader.Builder createGlobalLoaderBuilder() {
+        return super.createGlobalLoaderBuilder()
+            .defaultOptions(SakuraConfigurations::defaultGlobalOptions);
+    }
+
+    private static ConfigurationOptions defaultGlobalOptions(ConfigurationOptions options) {
+        return options
+            .header(GLOBAL_HEADER)
+            .serializers(builder -> builder
+                .register(new PacketClassSerializer())
+                .register(IntOr.Default.SERIALIZER)
+            );
+    }
+
+    @Override
+    public GlobalConfiguration initializeGlobalConfiguration() throws ConfigurateException {
+        GlobalConfiguration configuration = super.initializeGlobalConfiguration();
+        GlobalConfiguration.set(configuration);
+        return configuration;
+    }
+
+    @Override
+    protected ObjectMapper.Factory.Builder createWorldObjectMapperFactoryBuilder(final ContextMap contextMap) {
+        return super.createWorldObjectMapperFactoryBuilder(contextMap)
+            .addNodeResolver(new NestedSetting.Factory())
+            .addDiscoverer(InnerClassFieldDiscoverer.worldConfig(createWorldConfigInstance(contextMap)));
+    }
+
+    private static WorldConfiguration createWorldConfigInstance(ContextMap contextMap) {
+        return new WorldConfiguration(
+            contextMap.require(Configurations.WORLD_KEY)
+        );
+    }
+
+    @Override
+    protected YamlConfigurationLoader.Builder createWorldConfigLoaderBuilder(final ContextMap contextMap) {
+        return super.createWorldConfigLoaderBuilder(contextMap)
+            .defaultOptions(options -> options
+                .header(contextMap.require(WORLD_NAME).equals(WORLD_DEFAULTS) ? WORLD_DEFAULTS_HEADER : WORLD_HEADER.apply(contextMap))
+                .serializers(serializers -> serializers
+                    .register(new TypeToken<Reference2IntMap<?>>() {}, new FastutilMapSerializer.SomethingToPrimitive<Reference2IntMap<?>>(Reference2IntOpenHashMap::new, Integer.TYPE))
+                    .register(new TypeToken<Reference2LongMap<?>>() {}, new FastutilMapSerializer.SomethingToPrimitive<Reference2LongMap<?>>(Reference2LongOpenHashMap::new, Long.TYPE))
+                    .register(new TypeToken<Table<?, ?, ?>>() {}, new TableSerializer())
+                    .register(StringRepresentableSerializer::isValidFor, new StringRepresentableSerializer())
+                    .register(IntOr.Default.SERIALIZER)
+                    .register(IntOr.Disabled.SERIALIZER)
+                    .register(DoubleOr.Default.SERIALIZER)
+                    .register(BooleanOrDefault.SERIALIZER)
+                    .register(Duration.SERIALIZER)
+                    .register(DurationOrDisabled.SERIALIZER)
+                    .register(EngineMode.SERIALIZER)
+                    .register(NbtPathSerializer.SERIALIZER)
+                    .register(new RegistryValueSerializer<>(new TypeToken<EntityType<?>>() {}, Registries.ENTITY_TYPE, true))
+                    .register(new RegistryValueSerializer<>(Item.class, Registries.ITEM, true))
+                    .register(new RegistryHolderSerializer<>(new TypeToken<ConfiguredFeature<?, ?>>() {}, Registries.CONFIGURED_FEATURE, false))
+                    .register(new RegistryHolderSerializer<>(Item.class, Registries.ITEM, true))
+                )
+            );
+    }
+
+    @Override
+    public WorldConfiguration createWorldConfig(final ContextMap contextMap) {
+        final String levelName = contextMap.require(WORLD_NAME);
+        try {
+            return super.createWorldConfig(contextMap);
+        } catch (IOException exception) {
+            throw new RuntimeException("Could not create world config for " + levelName, exception);
+        }
+    }
+
+    @Override
+    protected boolean isConfigType(final Type type) {
+        return ConfigurationPart.class.isAssignableFrom(erase(type));
+    }
+
+    public void reloadConfigs(MinecraftServer server) {
+        try {
+            this.initializeGlobalConfiguration(reloader(this.globalConfigClass, GlobalConfiguration.get()));
+            this.initializeWorldDefaultsConfiguration();
+            for (ServerLevel level : server.getAllLevels()) {
+                this.createWorldConfig(createWorldContextMap(level), reloader(this.worldConfigClass, level.sakuraConfig()));
+            }
+        } catch (Exception ex) {
+            throw new RuntimeException("Could not reload paper configuration files", ex);
+        }
+    }
+
+    private static ContextMap createWorldContextMap(ServerLevel level) {
+        return createWorldContextMap(level.convertable.levelDirectory.path(), level.serverLevelData.getLevelName(), level.dimension().location());
+    }
+
+    public static ContextMap createWorldContextMap(Path dir, String levelName, ResourceLocation worldKey) {
+        return ContextMap.builder()
+            .put(WORLD_DIRECTORY, dir)
+            .put(WORLD_NAME, levelName)
+            .put(WORLD_KEY, worldKey)
+            .build();
+    }
+
+    public static SakuraConfigurations setup(final Path configDir) {
+        try {
+            PaperConfigurations.createDirectoriesSymlinkAware(configDir);
+            return new SakuraConfigurations(configDir);
+        } catch (final IOException ex) {
+            throw new RuntimeException("Could not setup PaperConfigurations", ex);
+        }
+    }
+
+}
diff --git a/src/main/java/me/samsuik/sakura/configuration/WorldConfiguration.java b/src/main/java/me/samsuik/sakura/configuration/WorldConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e106a2bd35ff0250813b7a6f8224e7968c27722
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/configuration/WorldConfiguration.java
@@ -0,0 +1,64 @@
+package me.samsuik.sakura.configuration;
+
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.configuration.Configuration;
+import io.papermc.paper.configuration.ConfigurationPart;
+import io.papermc.paper.configuration.PaperConfigurations;
+import me.samsuik.sakura.entity.merge.MergeLevel;
+import net.minecraft.resources.ResourceLocation;
+import org.slf4j.Logger;
+import org.spongepowered.configurate.objectmapping.meta.Setting;
+
+@SuppressWarnings({"FieldCanBeLocal", "FieldMayBeFinal", "NotNullFieldNotInitialized", "InnerClassMayBeStatic", "RedundantSuppression"})
+public class WorldConfiguration extends ConfigurationPart {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+    static final int CURRENT_VERSION = 1; // (when you change the version, change the comment, so it conflicts on rebases): rename filter bad nbt from spawn eggs
+
+    private transient final ResourceLocation worldKey;
+    WorldConfiguration(ResourceLocation worldKey) {
+        this.worldKey = worldKey;
+    }
+
+    public boolean isDefault() {
+        return this.worldKey.equals(PaperConfigurations.WORLD_DEFAULTS_KEY);
+    }
+
+    @Setting(Configuration.VERSION_FIELD)
+    public int version = CURRENT_VERSION;
+
+    public Cannons cannons;
+    public class Cannons extends ConfigurationPart {
+        public MergeLevel mergeLevel = MergeLevel.STRICT;
+
+        public Tnt tnt = new Tnt();
+        public class Tnt extends ConfigurationPart {
+            public boolean loadsChunks;
+            public boolean forcePositionUpdates;
+        }
+
+        public Sand sand = new Sand();
+        public class Sand extends ConfigurationPart {
+            public boolean loadsChunks;
+            public boolean despawnInsideMovingPistons = true;
+        }
+
+        public Explosion explosion = new Explosion();
+        public class Explosion extends ConfigurationPart {
+            public boolean optimiseProtectedRegions = true;
+            public boolean avoidRedundantBlockSearches = true;
+        }
+
+        public Mechanics mechanics = new Mechanics();
+        public class Mechanics extends ConfigurationPart {
+            public TNTSpread tntSpread = TNTSpread.ALL;
+            public boolean tntFlowsInWater = true;
+            public boolean fallingBlockParity = false;
+
+            public enum TNTSpread {
+                ALL, Y, NONE;
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/me/samsuik/sakura/configuration/mapping/InnerClassFieldDiscoverer.java b/src/main/java/me/samsuik/sakura/configuration/mapping/InnerClassFieldDiscoverer.java
new file mode 100644
index 0000000000000000000000000000000000000000..96080117b5ac9dea6b9eeb7489dc0c87d2c5f8a1
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/configuration/mapping/InnerClassFieldDiscoverer.java
@@ -0,0 +1,55 @@
+package me.samsuik.sakura.configuration.mapping;
+
+import io.papermc.paper.configuration.ConfigurationPart;
+import io.papermc.paper.configuration.mapping.InnerClassInstanceFactory;
+import io.papermc.paper.configuration.mapping.InnerClassInstanceSupplier;
+import me.samsuik.sakura.configuration.WorldConfiguration;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.objectmapping.FieldDiscoverer;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.reflect.AnnotatedType;
+import java.lang.reflect.Field;
+import java.util.Collections;
+import java.util.Map;
+
+import static io.leangen.geantyref.GenericTypeReflector.erase;
+
+public final class InnerClassFieldDiscoverer implements FieldDiscoverer<Map<Field, Object>> {
+
+    private final InnerClassInstanceSupplier instanceSupplier;
+    private final FieldDiscoverer<Map<Field, Object>> delegate;
+
+    @SuppressWarnings("unchecked")
+    public InnerClassFieldDiscoverer(final Map<Class<?>, Object> initialOverrides) {
+        this.instanceSupplier = new InnerClassInstanceSupplier(initialOverrides);
+        this.delegate = (FieldDiscoverer<Map<Field, Object>>) FieldDiscoverer.object(this.instanceSupplier);
+    }
+
+    @Override
+    public @Nullable <V> InstanceFactory<Map<Field, Object>> discover(final AnnotatedType target, final FieldCollector<Map<Field, Object>, V> collector) throws SerializationException {
+        final Class<?> clazz = erase(target.getType());
+        if (ConfigurationPart.class.isAssignableFrom(clazz)) {
+            final @Nullable InstanceFactory<Map<Field, Object>> instanceFactoryDelegate = this.delegate.<V>discover(target, (name, type, annotations, deserializer, serializer) -> {
+                if (!erase(type.getType()).equals(clazz.getEnclosingClass())) { // don't collect synth fields for inner classes
+                    collector.accept(name, type, annotations, deserializer, serializer);
+                }
+            });
+            if (instanceFactoryDelegate instanceof MutableInstanceFactory<Map<Field, Object>> mutableInstanceFactoryDelegate) {
+                return new InnerClassInstanceFactory(this.instanceSupplier, mutableInstanceFactoryDelegate, target);
+            }
+        }
+        return null;
+    }
+
+    public static FieldDiscoverer<?> worldConfig(WorldConfiguration worldConfiguration) {
+        final Map<Class<?>, Object> overrides = Map.of(
+            WorldConfiguration.class, worldConfiguration
+        );
+        return new InnerClassFieldDiscoverer(overrides);
+    }
+
+    public static FieldDiscoverer<?> globalConfig() {
+        return new InnerClassFieldDiscoverer(Collections.emptyMap());
+    }
+}
diff --git a/src/main/java/me/samsuik/sakura/utils/VariousHelpers.java b/src/main/java/me/samsuik/sakura/utils/VariousHelpers.java
new file mode 100644
index 0000000000000000000000000000000000000000..141b15887ca075fef5d36ff15125b3e071049917
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/utils/VariousHelpers.java
@@ -0,0 +1,61 @@
+package me.samsuik.sakura.utils;
+
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.world.entity.EntityType;
+
+import java.util.List;
+import java.util.regex.Pattern;
+import org.apache.commons.lang.StringUtils;
+
+public class VariousHelpers {
+
+    public static List<EntityType<?>> getEntityTypes(String from) {
+        Pattern pattern = VariousHelpers.wildcardPattern(from);
+
+        return BuiltInRegistries.ENTITY_TYPE.stream()
+            .filter((type) -> pattern.matcher(type.getDescriptionId()).find()
+                || pattern.matcher(type.getCategory().getName()).find())
+            .toList();
+    }
+
+    public static Pattern wildcardPattern(String string) {
+        String included = string.replaceAll("\\*{2}", ".*?");
+        return Pattern.compile("^(%s)$".formatted(included));
+    }
+    
+    public static String capitalise(String string) {
+        StringBuilder builder = new StringBuilder(string.length());
+        boolean capitalise = true;
+
+        for (char character : string.toCharArray()) {
+            if (!Character.isAlphabetic(character)) {
+                capitalise = true;
+            } else if (capitalise) {
+                character = Character.toUpperCase(character);
+                capitalise = false;
+            }
+
+            builder.append(character);
+        }
+
+        return builder.toString();
+    }
+
+    public static int sequential(String of, String provided) {
+        for (int i = 0; i < of.length() && i < provided.length(); ++i) {
+            if (provided.charAt(i) != of.charAt(i)) {
+                return i;
+            }
+        }
+
+        return Math.min(of.length(), provided.length());
+    }
+
+    public static double similarity(String a, String b) {
+        double distance = StringUtils.getLevenshteinDistance(a, b);
+        int highest = Math.max(a.length(), b.length());
+        return 1 - (distance / highest);
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index a9494fe4ef242eeee02eca2c1d69e46539dfe719..9c5c633587d6781a72d9eb258ba5a4a35e954144 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -300,6 +300,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public final double[] recentTps = new double[ 3 ];
     // Spigot end
     public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations;
+    public final me.samsuik.sakura.configuration.SakuraConfigurations sakuraConfigurations; // Sakura - missing paper comment above D:
     public static long currentTickLong = 0L; // Paper
 
     public volatile Thread shutdownThread; // Paper
@@ -405,6 +406,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
         // CraftBukkit end
         this.paperConfigurations = services.paperConfigurations(); // Paper
+        // Sakura start
+        final var sakuraConfigDirPath = ((File) options.valueOf("sakura-settings-directory")).toPath();
+        this.sakuraConfigurations = me.samsuik.sakura.configuration.SakuraConfigurations.setup(sakuraConfigDirPath);
+        // Sakura end
     }
 
     private void readScoreboard(DimensionDataStorage persistentStateManager) {
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index cf605aa56adf7f80d3b409f60a92a5ca7ae8fd07..c79284371055aacc4ec5cf11d7cd375ec15efc4c 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -221,6 +221,11 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // load version history now
         io.papermc.paper.brigadier.PaperBrigadierProviderImpl.INSTANCE.getClass(); // init PaperBrigadierProvider
         // Paper end
+        // Sakura start
+        sakuraConfigurations.initializeGlobalConfiguration();
+        sakuraConfigurations.initializeWorldDefaultsConfiguration();
+        me.samsuik.sakura.command.SakuraCommands.registerCommands(this);
+        // Sakura end
 
         this.setPvpAllowed(dedicatedserverproperties.pvp);
         this.setFlightAllowed(dedicatedserverproperties.allowFlight);
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 584a768f2ce1c98a1de7749060c47f21721f9055..c661de08862b4619f7d75606cac9a913fe154386 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -691,7 +691,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         // Holder holder = worlddimension.type(); // CraftBukkit - decompile error
 
         // Objects.requireNonNull(minecraftserver); // CraftBukkit - decompile error
-        super(iworlddataserver, resourcekey, minecraftserver.registryAccess(), worlddimension.type(), minecraftserver::getProfiler, false, flag, i, minecraftserver.getMaxChainedNeighborUpdates(), gen, biomeProvider, env, spigotConfig -> minecraftserver.paperConfigurations.createWorldConfig(io.papermc.paper.configuration.PaperConfigurations.createWorldContextMap(convertable_conversionsession.levelDirectory.path(), iworlddataserver.getLevelName(), resourcekey.location(), spigotConfig)), executor); // Paper - Async-Anti-Xray - Pass executor
+        super(iworlddataserver, resourcekey, minecraftserver.registryAccess(), worlddimension.type(), minecraftserver::getProfiler, false, flag, i, minecraftserver.getMaxChainedNeighborUpdates(), gen, biomeProvider, env, spigotConfig -> minecraftserver.paperConfigurations.createWorldConfig(io.papermc.paper.configuration.PaperConfigurations.createWorldContextMap(convertable_conversionsession.levelDirectory.path(), iworlddataserver.getLevelName(), resourcekey.location(), spigotConfig)), () -> minecraftserver.sakuraConfigurations.createWorldConfig(me.samsuik.sakura.configuration.SakuraConfigurations.createWorldContextMap(convertable_conversionsession.levelDirectory.path(), iworlddataserver.getLevelName(), resourcekey.location())), executor); // Sakura // Paper - Async-Anti-Xray - Pass executor
         this.pvpMode = minecraftserver.isPvpAllowed();
         this.convertable = convertable_conversionsession;
         this.uuid = WorldUUID.getUUID(convertable_conversionsession.levelDirectory.path().toFile());
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 2354a0e5d15e9be633d9fe3a1a9feefe7b9b7782..11ab3a3b8624c36dfde3d42091af67c51340e8f2 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -174,6 +174,12 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         return this.paperConfig;
     }
     // Paper end
+    // Sakura start
+    private final me.samsuik.sakura.configuration.WorldConfiguration sakuraConfig;
+    public me.samsuik.sakura.configuration.WorldConfiguration sakuraConfig() {
+        return this.sakuraConfig;
+    }
+    // Sakura end
 
     public final com.destroystokyo.paper.antixray.ChunkPacketBlockController chunkPacketBlockController; // Paper - Anti-Xray
     public final co.aikar.timings.WorldTimingsHandler timings; // Paper
@@ -210,9 +216,10 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
     public abstract ResourceKey<LevelStem> getTypeKey();
 
-    protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, Supplier<ProfilerFiller> supplier, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, java.util.concurrent.Executor executor) { // Paper - Async-Anti-Xray - Pass executor
+    protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, Supplier<ProfilerFiller> supplier, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, Supplier<me.samsuik.sakura.configuration.WorldConfiguration> sakuraWorldConfigCreator, java.util.concurrent.Executor executor) { // Sakura // Paper - Async-Anti-Xray - Pass executor
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) worlddatamutable).getLevelName()); // Spigot
         this.paperConfig = paperWorldConfigCreator.apply(this.spigotConfig); // Paper
+        this.sakuraConfig = sakuraWorldConfigCreator.get(); // Sakura
         this.generator = gen;
         this.world = new CraftWorld((ServerLevel) this, gen, biomeProvider, env);
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 1d98df3b60721568f69adc4ff10cc23d5d26504e..9b0e7524f2f223fb0927332879f5602f66696705 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1041,6 +1041,7 @@ public final class CraftServer implements Server {
 
         org.spigotmc.SpigotConfig.init((File) this.console.options.valueOf("spigot-settings")); // Spigot
         this.console.paperConfigurations.reloadConfigs(this.console);
+        this.console.sakuraConfigurations.reloadConfigs(this.console); // Sakura - missing comment above
         for (ServerLevel world : this.console.getAllLevels()) {
             // world.serverLevelData.setDifficulty(config.difficulty); // Paper - per level difficulty
             world.setSpawnSettings(world.serverLevelData.getDifficulty() != Difficulty.PEACEFUL && config.spawnMonsters, config.spawnAnimals); // Paper - per level difficulty (from MinecraftServer#setDifficulty(ServerLevel, Difficulty, boolean))
@@ -1071,6 +1072,7 @@ public final class CraftServer implements Server {
         this.reloadData();
         org.spigotmc.SpigotConfig.registerCommands(); // Spigot
         io.papermc.paper.command.PaperCommands.registerCommands(this.console); // Paper
+        me.samsuik.sakura.command.SakuraCommands.registerCommands(this.console); // Sakura
         this.overrideAllCommandBlockCommands = this.commandsConfiguration.getStringList("command-block-overrides").contains("*");
         this.ignoreVanillaPermissions = this.commandsConfiguration.getBoolean("ignore-vanilla-permissions");
 
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 2af0068ef338634d1f44532af5db66c2d0b3dd10..65cadd91f2a0932f01bb30b036e249c37d69feec 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -173,6 +173,14 @@ public class Main {
                         .describedAs("Jar file");
                 // Paper end
 
+                // Sakura start
+                acceptsAll(asList("sakura-dir", "sakura-settings-directory"), "Directory for Sakura settings")
+                    .withRequiredArg()
+                    .ofType(File.class)
+                    .defaultsTo(new File(me.samsuik.sakura.configuration.SakuraConfigurations.CONFIG_DIR))
+                    .describedAs("Config directory");
+                // Sakura end
+
                 // Paper start
                 acceptsAll(asList("server-name"), "Name of the server")
                         .withRequiredArg()
